<!DOCTYPE html>
<html>
  <head>
    <title>stratum-observer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
  </head>
  <body>
    <h1>Hello, world!</h1>

    <table class="table table-striped table-sm table-responsive" id="jobs">
      <thead>
        <tr>
          <td>name</td>
          <td>coinbase tag</td>
          <td>height</td>
          <td>prev_hash</td>
          <td>age</td>
          <td>clear</td>
          <td>output sum</td>
          <td>merkle-branches</td>
          <td>name</td>
          <td>header time offset</td>
          <td>header version</td>
        </tr>
      </thead>
      <tbody>
        <!-- to be filled with stratum job data by js -->
      </tbody>
    </table>

    <template id="job_row">
      <tr>
        <td>name</td>
        <td>coinbase tag</td>
        <td>height</td>
        <td><!--prev_hash--></td>
        <td><!--age--></td>
        <td>clear</td>
        <td>output sum</td>
        <td><!--merkle-branches--></td>
        <td><!--name--></td>
        <td><!--name--></td>
        <td><!--name--></td>
      </tr>
    </template>
    
    <script>

      const tbody = document.querySelector("tbody");
      const template = document.querySelector("#job_row");
      const jobs = new Map();
      const socket = new WebSocket(
        "ws://127.0.0.1:9555",
      );

      socket.onmessage = (event) => {
        let job = JSON.parse(event.data)
        jobs[job.pool_name] = job;
        draw()
      };

      function draw() {
        let rows = [];
        for(const pool in jobs) {
          const job = jobs[pool]
          const clone = template.content.cloneNode(true);
          let td = clone.querySelectorAll("td");
          td[0].textContent = job.pool_name;
          td[1].textContent = job.coinbase_tag;
          td[2].textContent = job.height;
          const aPrevHash = document.createElement('a')
          const span = document.createElement('span')
          span.textContent = ".." + job.prev_hash.substring(56, 64);
          span.style.color = "#" + job.prev_hash.substring(58, 64);
          aPrevHash.append(span)
          aPrevHash.setAttribute("href", "https://mempool.space/block/" + job.prev_hash)
          td[3].appendChild(aPrevHash);
          
          const spanTimestamp = document.createElement('span')
          spanTimestamp.classList.add("relativeTimestamp")
          spanTimestamp.setAttribute("data-timestamp", job.job_timestamp)
          spanTimestamp.textContent = ((Date.now() - job.job_timestamp*1000)/1000).toFixed(0) + "s"
          td[4].appendChild(spanTimestamp);
          
          td[5].textContent = job.clean_jobs;
          td[6].textContent = (job.coinbase_sum / 100_000_000).toFixed(8) + " BTC";
          for (b of job.merkle_branches) {
            const span = document.createElement('span')
            span.textContent = "____";
            span.style.background = "#" + b.substring(0, 6);
            td[7].appendChild(span)
          }
          td[8].textContent = job.pool_name;
          td[9].textContent = job.job_timestamp - job.header_time + "s";
          td[10].textContent = job.header_version;
          rows.push({"cb_sum": job.coinbase_sum, "job_ts": job.job_timestamp, "element": clone});
        }
        rows.sort((a, b) => {
            var keyA = a["cb_sum"], keyB = b["cb_sum"];
            if (keyA < keyB) return 1;
            if (keyA > keyB) return -1;
            return 0;
          });
        
        tbody.replaceChildren(...rows.map(e => e.element));
      }

      function periodicallyRedrawTimestamps() {
        setTimeout(() => {
          let ts = document.getElementsByClassName("relativeTimestamp");
          for(t of ts) {
            let timestamp = parseInt(t.dataset.timestamp)
            t.innerHTML = ((Date.now() - timestamp*1000)/1000).toFixed(0) + "s"
          }
          periodicallyRedrawTimestamps()
        }, 1000)
      }
      periodicallyRedrawTimestamps()
    </script>
  </body>
</html>
